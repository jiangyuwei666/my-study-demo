# -*- coding: utf-8 -*-
"""
约瑟夫环问题
"""
"""
假设问题是从n个人编号分别为0...n-1，取第k个，则第k个人编号为k-1的淘汰，剩下的编号为  0,1,2,3...k-2,k,k+1,k+2...此时因为从刚刚淘汰那个人的下一个开始数起，因此重新编号把k号设置为0,则k    0k+1 1...0 n-k1 n-k+1假设已经求得了n-1个人情况下的最终胜利者保存在f[n-1]中，则毫无疑问，该胜利者还原到原来的真正编号即为 (f[n-1]+k)%n （因为第二轮重新编号的时候，相当于把每个人的编号都减了k，因此重新+k即可恢复到原来编号）。由此，我们可以想象，当最终只剩下一个人的时候，该人即为胜利者，此时重新编号，因为只有一个人，所以此时f[1]=0这样f[2]=(f[1]+k)%2,这样就可以求出最终胜利者在2个人的时候的情况下的编号，由递推公式f[n]=(f[n-1]+k)%n,可递推到最初编号序列中该胜利者的编号
用new表示下一轮的编号，old表示当前编号：
new = (old-q) % n
所以胜利的人上一轮编号就是：
old = (new+k) % n

所以有递推公式：
f(1) = 1
f(i) = (f(i - 1) + m) % i
"""


def get_winner(m, n):
    """
    :param m: 一共有多少人
    :param n: 步长
    """
    result = 1
    for i in range(2, m + 1):
        result = (result + n) % i
    print(result)


get_winner(14, 3)
get_winner(11, 3)
get_winner(2, 3)
get_winner(2, 2)
get_winner(3, 3)
