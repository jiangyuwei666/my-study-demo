"""
思路一：这个题最简单最容易想到的还是将已经访问过的元素存在hash表中，但是就需要额外开辟空间

思路二：扫描数组的时候，因为所有数都是在0~n-1之间的，所以可以将遍历的相应的数字放在相应的位置上

思路三：题目里写了数组里数字的范围保证在0 ~ n-1 之间，所以可以利用现有数组设置标志，当一个数字被访问过后，可以设置对应位上的数 + n，之后再遇到相同的数时，会发现对应位上的数已经大于等于n了，那么直接返回这个数即可。
三种思路的时间复杂度都是O(n)
"""


def get_repeat(arr):
    n = len(arr)
    for i in range(n):
        while arr[i] != i:
            if arr[i] == arr[arr[i]]:
                return arr[i]
            arr[arr[i]], arr[i] = arr[i], arr[arr[i]]



print(get_repeat([2, 3, 1, 0, 2, 5, 3]))
